/**
 * OpenClaw Plugin Types (locally defined)
 *
 * OpenClaw's plugin SDK uses duck typing — these match the shapes
 * expected by registerProvider() and the plugin system.
 * Defined locally to avoid depending on internal OpenClaw paths.
 */
type ModelApi = "openai-completions" | "openai-responses" | "anthropic-messages" | "google-generative-ai" | "github-copilot" | "bedrock-converse-stream";
type ModelDefinitionConfig = {
    id: string;
    name: string;
    api?: ModelApi;
    reasoning: boolean;
    input: Array<"text" | "image">;
    cost: {
        input: number;
        output: number;
        cacheRead: number;
        cacheWrite: number;
    };
    contextWindow: number;
    maxTokens: number;
    headers?: Record<string, string>;
};
type ModelProviderConfig = {
    baseUrl: string;
    apiKey?: string;
    api?: ModelApi;
    headers?: Record<string, string>;
    authHeader?: boolean;
    models: ModelDefinitionConfig[];
};
type AuthProfileCredential = {
    apiKey?: string;
    type?: string;
    [key: string]: unknown;
};
type ProviderAuthResult = {
    profiles: Array<{
        profileId: string;
        credential: AuthProfileCredential;
    }>;
    configPatch?: Record<string, unknown>;
    defaultModel?: string;
    notes?: string[];
};
type WizardPrompter = {
    text: (opts: {
        message: string;
        validate?: (value: string) => string | undefined;
    }) => Promise<string | symbol>;
    note: (message: string) => void;
    progress: (message: string) => {
        stop: (message?: string) => void;
    };
};
type ProviderAuthContext = {
    config: Record<string, unknown>;
    agentDir?: string;
    workspaceDir?: string;
    prompter: WizardPrompter;
    runtime: {
        log: (message: string) => void;
    };
    isRemote: boolean;
    openUrl: (url: string) => Promise<void>;
};
type ProviderAuthMethod = {
    id: string;
    label: string;
    hint?: string;
    kind: "oauth" | "api_key" | "token" | "device_code" | "custom";
    run: (ctx: ProviderAuthContext) => Promise<ProviderAuthResult>;
};
type ProviderPlugin = {
    id: string;
    label: string;
    docsPath?: string;
    aliases?: string[];
    envVars?: string[];
    models?: ModelProviderConfig;
    auth: ProviderAuthMethod[];
    formatApiKey?: (cred: AuthProfileCredential) => string;
};
type PluginLogger = {
    debug?: (message: string) => void;
    info: (message: string) => void;
    warn: (message: string) => void;
    error: (message: string) => void;
};
type OpenClawPluginService = {
    id: string;
    start: () => void | Promise<void>;
    stop?: () => void | Promise<void>;
};
type OpenClawPluginApi = {
    id: string;
    name: string;
    version?: string;
    description?: string;
    source: string;
    config: Record<string, unknown> & {
        models?: {
            providers?: Record<string, ModelProviderConfig>;
        };
        agents?: Record<string, unknown>;
    };
    pluginConfig?: Record<string, unknown>;
    logger: PluginLogger;
    registerProvider: (provider: ProviderPlugin) => void;
    registerTool: (tool: unknown, opts?: unknown) => void;
    registerHook: (events: string | string[], handler: unknown, opts?: unknown) => void;
    registerHttpRoute: (params: {
        path: string;
        handler: unknown;
    }) => void;
    registerService: (service: OpenClawPluginService) => void;
    registerCommand: (command: unknown) => void;
    resolvePath: (input: string) => string;
    on: (hookName: string, handler: unknown, opts?: unknown) => void;
};
type OpenClawPluginDefinition = {
    id?: string;
    name?: string;
    description?: string;
    version?: string;
    register?: (api: OpenClawPluginApi) => void | Promise<void>;
    activate?: (api: OpenClawPluginApi) => void | Promise<void>;
};

/**
 * Payment Parameter Cache
 *
 * Caches the 402 payment parameters (payTo, asset, network, etc.) after the first
 * request to each endpoint. On subsequent requests, pre-signs the payment and
 * attaches it to the first request, skipping the 402 round trip (~200ms savings).
 */
type CachedPaymentParams = {
    payTo: string;
    asset: string;
    scheme: string;
    network: string;
    extra?: {
        name?: string;
        version?: string;
    };
    maxTimeoutSeconds?: number;
    resourceUrl?: string;
    resourceDescription?: string;
    cachedAt: number;
};
declare class PaymentCache {
    private cache;
    private ttlMs;
    constructor(ttlMs?: number);
    /** Get cached payment params for an endpoint path. */
    get(endpointPath: string): CachedPaymentParams | undefined;
    /** Cache payment params from a 402 response. */
    set(endpointPath: string, params: Omit<CachedPaymentParams, "cachedAt">): void;
    /** Invalidate cache for an endpoint (e.g., if payTo changed). */
    invalidate(endpointPath: string): void;
}

/**
 * x402 Payment Implementation
 *
 * Based on BlockRun's proven implementation.
 * Handles 402 Payment Required responses with EIP-712 signed USDC transfers.
 *
 * Optimizations (v0.3.0):
 *   - Payment cache: after first 402, caches {payTo, asset, network} per endpoint.
 *     On subsequent requests, pre-signs payment and sends with first request,
 *     skipping the 402 round trip (~200ms savings).
 *   - Falls back to normal 402 flow if pre-signed payment is rejected.
 */

/** Pre-auth parameters for skipping the 402 round trip. */
type PreAuthParams = {
    estimatedAmount: string;
};
/** Result from createPaymentFetch — includes the fetch wrapper and payment cache. */
type PaymentFetchResult = {
    fetch: (input: RequestInfo | URL, init?: RequestInit, preAuth?: PreAuthParams) => Promise<Response>;
    cache: PaymentCache;
};
/**
 * Create a fetch wrapper that handles x402 payment automatically.
 *
 * Supports pre-auth: if cached payment params + estimated amount are available,
 * pre-signs and attaches payment to the first request, skipping the 402 round trip.
 * Falls back to normal 402 flow if pre-signed payment is rejected.
 */
declare function createPaymentFetch(privateKey: `0x${string}`): PaymentFetchResult;

/**
 * Smart Router Types
 *
 * Four classification tiers — REASONING is distinct from COMPLEX because
 * reasoning tasks need different models (o3, gemini-pro) than general
 * complex tasks (gpt-4o, sonnet-4).
 *
 * Scoring uses weighted float dimensions with sigmoid confidence calibration.
 */
type Tier = "SIMPLE" | "MEDIUM" | "COMPLEX" | "REASONING";
type RoutingDecision = {
    model: string;
    tier: Tier;
    confidence: number;
    method: "rules" | "llm";
    reasoning: string;
    costEstimate: number;
    baselineCost: number;
    savings: number;
};
type TierConfig = {
    primary: string;
    fallback: string[];
};
type ScoringConfig = {
    tokenCountThresholds: {
        simple: number;
        complex: number;
    };
    codeKeywords: string[];
    reasoningKeywords: string[];
    simpleKeywords: string[];
    technicalKeywords: string[];
    creativeKeywords: string[];
    imperativeVerbs: string[];
    constraintIndicators: string[];
    outputFormatKeywords: string[];
    referenceKeywords: string[];
    negationKeywords: string[];
    domainSpecificKeywords: string[];
    agenticTaskKeywords: string[];
    dimensionWeights: Record<string, number>;
    tierBoundaries: {
        simpleMedium: number;
        mediumComplex: number;
        complexReasoning: number;
    };
    confidenceSteepness: number;
    confidenceThreshold: number;
};
type ClassifierConfig = {
    llmModel: string;
    llmMaxTokens: number;
    llmTemperature: number;
    promptTruncationChars: number;
    cacheTtlMs: number;
};
type OverridesConfig = {
    maxTokensForceComplex: number;
    structuredOutputMinTier: Tier;
    ambiguousDefaultTier: Tier;
    /**
     * When enabled, prefer models optimized for agentic workflows.
     * Agentic models continue autonomously with multi-step tasks
     * instead of stopping and waiting for user input.
     */
    agenticMode?: boolean;
};
type RoutingConfig = {
    version: string;
    classifier: ClassifierConfig;
    scoring: ScoringConfig;
    tiers: Record<Tier, TierConfig>;
    /** Tier configs for agentic mode - models that excel at multi-step tasks */
    agenticTiers?: Record<Tier, TierConfig>;
    /** Tier configs for eco profile - ultra cost-optimized (blockrun/eco) */
    ecoTiers?: Record<Tier, TierConfig>;
    /** Tier configs for premium profile - best quality (blockrun/premium) */
    premiumTiers?: Record<Tier, TierConfig>;
    overrides: OverridesConfig;
};

/**
 * Tier → Model Selection
 *
 * Maps a classification tier to the cheapest capable model.
 * Builds RoutingDecision metadata with cost estimates and savings.
 */

type ModelPricing = {
    inputPrice: number;
    outputPrice: number;
};
/**
 * Get the ordered fallback chain for a tier: [primary, ...fallbacks].
 */
declare function getFallbackChain(tier: Tier, tierConfigs: Record<Tier, TierConfig>): string[];
/**
 * Calculate cost for a specific model (used when fallback model is used).
 * Returns updated cost fields for RoutingDecision.
 */
declare function calculateModelCost(model: string, modelPricing: Map<string, ModelPricing>, estimatedInputTokens: number, maxOutputTokens: number, routingProfile?: "free" | "eco" | "auto" | "premium"): {
    costEstimate: number;
    baselineCost: number;
    savings: number;
};
/**
 * Get the fallback chain filtered by context length.
 * Only returns models that can handle the estimated total context.
 *
 * @param tier - The tier to get fallback chain for
 * @param tierConfigs - Tier configurations
 * @param estimatedTotalTokens - Estimated total context (input + output)
 * @param getContextWindow - Function to get context window for a model ID
 * @returns Filtered list of models that can handle the context
 */
declare function getFallbackChainFiltered(tier: Tier, tierConfigs: Record<Tier, TierConfig>, estimatedTotalTokens: number, getContextWindow: (modelId: string) => number | undefined): string[];

/**
 * Default Routing Config
 *
 * All routing parameters as a TypeScript constant.
 * Operators override via openclaw.yaml plugin config.
 *
 * Scoring uses 14 weighted dimensions with sigmoid confidence calibration.
 */

declare const DEFAULT_ROUTING_CONFIG: RoutingConfig;

/**
 * Smart Router Entry Point
 *
 * Classifies requests and routes to the cheapest capable model.
 * 100% local — rules-based scoring handles all requests in <1ms.
 * Ambiguous cases default to configurable tier (MEDIUM by default).
 */

type RouterOptions = {
    config: RoutingConfig;
    modelPricing: Map<string, ModelPricing>;
    routingProfile?: "free" | "eco" | "auto" | "premium";
};
/**
 * Route a request to the cheapest capable model.
 *
 * 1. Check overrides (large context, structured output)
 * 2. Run rule-based classifier (14 weighted dimensions, <1ms)
 * 3. If ambiguous, default to configurable tier (no external API calls)
 * 4. Select model for tier
 * 5. Return RoutingDecision with metadata
 */
declare function route(prompt: string, systemPrompt: string | undefined, maxOutputTokens: number, options: RouterOptions): RoutingDecision;

/**
 * Response Cache for LLM Completions
 *
 * Caches LLM responses by request hash (model + messages + params).
 * Inspired by LiteLLM's caching system. Returns cached responses for
 * identical requests, saving both cost and latency.
 *
 * Features:
 * - TTL-based expiration (default 10 minutes)
 * - LRU eviction when cache is full
 * - Size limits per item (1MB max)
 * - Heap-based expiration tracking for efficient pruning
 */
type CachedLLMResponse = {
    body: Buffer;
    status: number;
    headers: Record<string, string>;
    model: string;
    cachedAt: number;
    expiresAt: number;
};
type ResponseCacheConfig = {
    /** Maximum number of cached responses. Default: 200 */
    maxSize?: number;
    /** Default TTL in seconds. Default: 600 (10 minutes) */
    defaultTTL?: number;
    /** Maximum size per cached item in bytes. Default: 1MB */
    maxItemSize?: number;
    /** Enable/disable cache. Default: true */
    enabled?: boolean;
};
declare class ResponseCache {
    private cache;
    private expirationHeap;
    private config;
    private stats;
    constructor(config?: ResponseCacheConfig);
    /**
     * Generate cache key from request body.
     * Hashes: model + messages + temperature + max_tokens + other params
     */
    static generateKey(body: Buffer | string): string;
    /**
     * Check if caching is enabled for this request.
     * Respects cache control headers and request params.
     */
    shouldCache(body: Buffer | string, headers?: Record<string, string>): boolean;
    /**
     * Get cached response if available and not expired.
     */
    get(key: string): CachedLLMResponse | undefined;
    /**
     * Cache a response with optional custom TTL.
     */
    set(key: string, response: {
        body: Buffer;
        status: number;
        headers: Record<string, string>;
        model: string;
    }, ttlSeconds?: number): void;
    /**
     * Evict expired and oldest entries to make room.
     */
    private evict;
    /**
     * Get cache statistics.
     */
    getStats(): {
        size: number;
        maxSize: number;
        hits: number;
        misses: number;
        evictions: number;
        hitRate: string;
    };
    /**
     * Clear all cached entries.
     */
    clear(): void;
    /**
     * Check if cache is enabled.
     */
    isEnabled(): boolean;
}

/**
 * Balance Monitor for ClawRouter
 *
 * Monitors USDC balance on Base network with intelligent caching.
 * Provides pre-request balance checks to prevent failed payments.
 *
 * Caching Strategy:
 *   - TTL: 30 seconds (balance is cached to avoid excessive RPC calls)
 *   - Optimistic deduction: after successful payment, subtract estimated cost from cache
 *   - Invalidation: on payment failure, immediately refresh from RPC
 */
/** Balance thresholds in USDC smallest unit (6 decimals) */
declare const BALANCE_THRESHOLDS: {
    /** Low balance warning threshold: $1.00 */
    readonly LOW_BALANCE_MICROS: 1000000n;
    /** Effectively zero threshold: $0.0001 (covers dust/rounding) */
    readonly ZERO_THRESHOLD: 100n;
};
/** Balance information returned by checkBalance() */
type BalanceInfo = {
    /** Raw balance in USDC smallest unit (6 decimals) */
    balance: bigint;
    /** Formatted balance as "$X.XX" */
    balanceUSD: string;
    /** True if balance < $1.00 */
    isLow: boolean;
    /** True if balance < $0.0001 (effectively zero) */
    isEmpty: boolean;
    /** Wallet address for funding instructions */
    walletAddress: string;
};
/** Result from checkSufficient() */
type SufficiencyResult = {
    /** True if balance >= estimated cost */
    sufficient: boolean;
    /** Current balance info */
    info: BalanceInfo;
    /** If insufficient, the shortfall as "$X.XX" */
    shortfall?: string;
};
/**
 * Monitors USDC balance on Base network.
 *
 * Usage:
 *   const monitor = new BalanceMonitor("0x...");
 *   const info = await monitor.checkBalance();
 *   if (info.isLow) console.warn("Low balance!");
 */
declare class BalanceMonitor {
    private readonly client;
    private readonly walletAddress;
    /** Cached balance (null = not yet fetched) */
    private cachedBalance;
    /** Timestamp when cache was last updated */
    private cachedAt;
    constructor(walletAddress: string);
    /**
     * Check current USDC balance.
     * Uses cache if valid, otherwise fetches from RPC.
     */
    checkBalance(): Promise<BalanceInfo>;
    /**
     * Check if balance is sufficient for an estimated cost.
     *
     * @param estimatedCostMicros - Estimated cost in USDC smallest unit (6 decimals)
     */
    checkSufficient(estimatedCostMicros: bigint): Promise<SufficiencyResult>;
    /**
     * Optimistically deduct estimated cost from cached balance.
     * Call this after a successful payment to keep cache accurate.
     *
     * @param amountMicros - Amount to deduct in USDC smallest unit
     */
    deductEstimated(amountMicros: bigint): void;
    /**
     * Invalidate cache, forcing next checkBalance() to fetch from RPC.
     * Call this after a payment failure to get accurate balance.
     */
    invalidate(): void;
    /**
     * Force refresh balance from RPC (ignores cache).
     */
    refresh(): Promise<BalanceInfo>;
    /**
     * Format USDC amount (in micros) as "$X.XX".
     */
    formatUSDC(amountMicros: bigint): string;
    /**
     * Get the wallet address being monitored.
     */
    getWalletAddress(): string;
    /** Fetch balance from RPC */
    private fetchBalance;
    /** Build BalanceInfo from raw balance */
    private buildInfo;
}

/**
 * Session Persistence Store
 *
 * Tracks model selections per session to prevent model switching mid-task.
 * When a session is active, the router will continue using the same model
 * instead of re-routing each request.
 */
type SessionEntry = {
    model: string;
    tier: string;
    createdAt: number;
    lastUsedAt: number;
    requestCount: number;
};
type SessionConfig = {
    /** Enable session persistence (default: false) */
    enabled: boolean;
    /** Session timeout in ms (default: 30 minutes) */
    timeoutMs: number;
    /** Header name for session ID (default: X-Session-ID) */
    headerName: string;
};
declare const DEFAULT_SESSION_CONFIG: SessionConfig;
/**
 * Session persistence store for maintaining model selections.
 */
declare class SessionStore {
    private sessions;
    private config;
    private cleanupInterval;
    constructor(config?: Partial<SessionConfig>);
    /**
     * Get the pinned model for a session, if any.
     */
    getSession(sessionId: string): SessionEntry | undefined;
    /**
     * Pin a model to a session.
     */
    setSession(sessionId: string, model: string, tier: string): void;
    /**
     * Touch a session to extend its timeout.
     */
    touchSession(sessionId: string): void;
    /**
     * Clear a specific session.
     */
    clearSession(sessionId: string): void;
    /**
     * Clear all sessions.
     */
    clearAll(): void;
    /**
     * Get session stats for debugging.
     */
    getStats(): {
        count: number;
        sessions: Array<{
            id: string;
            model: string;
            age: number;
        }>;
    };
    /**
     * Clean up expired sessions.
     */
    private cleanup;
    /**
     * Stop the cleanup interval.
     */
    close(): void;
}
/**
 * Generate a session ID from request headers or create a default.
 */
declare function getSessionId(headers: Record<string, string | string[] | undefined>, headerName?: string): string | undefined;

/**
 * Local x402 Proxy Server
 *
 * Sits between OpenClaw's pi-ai (which makes standard OpenAI-format requests)
 * and BlockRun's API (which requires x402 micropayments).
 *
 * Flow:
 *   pi-ai → http://localhost:{port}/v1/chat/completions
 *        → proxy forwards to https://blockrun.ai/api/v1/chat/completions
 *        → gets 402 → @x402/fetch signs payment → retries
 *        → streams response back to pi-ai
 *
 * Optimizations (v0.3.0):
 *   - SSE heartbeat: for streaming requests, sends headers + heartbeat immediately
 *     before the x402 flow, preventing OpenClaw's 10-15s timeout from firing.
 *   - Response dedup: hashes request bodies and caches responses for 30s,
 *     preventing double-charging when OpenClaw retries after timeout.
 *   - Payment cache: after first 402, pre-signs subsequent requests to skip
 *     the 402 round trip (~200ms savings per request).
 *   - Smart routing: when model is "blockrun/auto", classify query and pick cheapest model.
 *   - Usage logging: log every request as JSON line to ~/.openclaw/blockrun/logs/
 */

/**
 * Get the proxy port from pre-loaded configuration.
 * Port is validated at module load time, this just returns the cached value.
 */
declare function getProxyPort(): number;
/** Callback info for low balance warning */
type LowBalanceInfo = {
    balanceUSD: string;
    walletAddress: string;
};
/** Callback info for insufficient funds error */
type InsufficientFundsInfo = {
    balanceUSD: string;
    requiredUSD: string;
    walletAddress: string;
};
type ProxyOptions = {
    walletKey: string;
    apiBase?: string;
    /** Port to listen on (default: 8402) */
    port?: number;
    routingConfig?: Partial<RoutingConfig>;
    /**
     * Custom payment-enabled fetch function. When provided, replaces the built-in
     * x402 payment handler. Use this to integrate alternative payment systems
     * (e.g., spend limits, budget enforcement, or custom payment flows).
     *
     * If not provided, uses built-in createPaymentFetch with walletKey.
     */
    paymentFetch?: (input: RequestInfo | URL, init?: RequestInit, preAuth?: PreAuthParams) => Promise<Response>;
    /** Request timeout in ms (default: 180000 = 3 minutes). Covers on-chain tx + LLM response. */
    requestTimeoutMs?: number;
    /** Skip balance checks (for testing only). Default: false */
    skipBalanceCheck?: boolean;
    /**
     * Session persistence config. When enabled, maintains model selection
     * across requests within a session to prevent mid-task model switching.
     */
    sessionConfig?: Partial<SessionConfig>;
    /**
     * Auto-compress large requests to reduce network usage.
     * When enabled, requests are automatically compressed using
     * LLM-safe context compression (15-40% reduction).
     * Default: true
     */
    autoCompressRequests?: boolean;
    /**
     * Threshold in KB to trigger auto-compression (default: 180).
     * Requests larger than this are compressed before sending.
     * Set to 0 to compress all requests.
     */
    compressionThresholdKB?: number;
    /**
     * Response caching config. When enabled, identical requests return
     * cached responses instead of making new API calls.
     * Default: enabled with 10 minute TTL, 200 max entries.
     */
    cacheConfig?: ResponseCacheConfig;
    onReady?: (port: number) => void;
    onError?: (error: Error) => void;
    onPayment?: (info: {
        model: string;
        amount: string;
        network: string;
    }) => void;
    onRouted?: (decision: RoutingDecision) => void;
    /** Called when balance drops below $1.00 (warning, request still proceeds) */
    onLowBalance?: (info: LowBalanceInfo) => void;
    /** Called when balance is insufficient for a request (request fails) */
    onInsufficientFunds?: (info: InsufficientFundsInfo) => void;
};
type ProxyHandle = {
    port: number;
    baseUrl: string;
    walletAddress: string;
    balanceMonitor: BalanceMonitor;
    close: () => Promise<void>;
};
/**
 * Start the local x402 proxy server.
 *
 * If a proxy is already running on the target port, reuses it instead of failing.
 * Port can be configured via BLOCKRUN_PROXY_PORT environment variable.
 *
 * Returns a handle with the assigned port, base URL, and a close function.
 */
declare function startProxy(options: ProxyOptions): Promise<ProxyHandle>;

/**
 * BlockRun ProviderPlugin for OpenClaw
 *
 * Registers BlockRun as an LLM provider in OpenClaw.
 * Uses a local x402 proxy to handle micropayments transparently —
 * pi-ai sees a standard OpenAI-compatible API at localhost.
 */

/**
 * BlockRun provider plugin definition.
 */
declare const blockrunProvider: ProviderPlugin;

/**
 * BlockRun Model Definitions for OpenClaw
 *
 * Maps BlockRun's 30+ AI models to OpenClaw's ModelDefinitionConfig format.
 * All models use the "openai-completions" API since BlockRun is OpenAI-compatible.
 *
 * Pricing is in USD per 1M tokens. Operators pay these rates via x402;
 * they set their own markup when reselling to end users (Phase 2).
 */

/**
 * Model aliases for convenient shorthand access.
 * Users can type `/model claude` instead of `/model blockrun/anthropic/claude-sonnet-4-6`.
 */
declare const MODEL_ALIASES: Record<string, string>;
/**
 * Resolve a model alias to its full model ID.
 * Also strips "blockrun/" prefix for direct model paths.
 * Examples:
 *   - "claude" -> "anthropic/claude-sonnet-4-6" (alias)
 *   - "blockrun/claude" -> "anthropic/claude-sonnet-4-6" (alias with prefix)
 *   - "blockrun/anthropic/claude-sonnet-4-6" -> "anthropic/claude-sonnet-4-6" (prefix stripped)
 *   - "openai/gpt-4o" -> "openai/gpt-4o" (unchanged)
 */
declare function resolveModelAlias(model: string): string;
type BlockRunModel = {
    id: string;
    name: string;
    /** Model version (e.g., "4.6", "3.1", "5.2") for tracking updates */
    version?: string;
    inputPrice: number;
    outputPrice: number;
    contextWindow: number;
    maxOutput: number;
    reasoning?: boolean;
    vision?: boolean;
    /** Models optimized for agentic workflows (multi-step autonomous tasks) */
    agentic?: boolean;
};
declare const BLOCKRUN_MODELS: BlockRunModel[];
/**
 * All BlockRun models in OpenClaw format (including aliases).
 */
declare const OPENCLAW_MODELS: ModelDefinitionConfig[];
/**
 * Build a ModelProviderConfig for BlockRun.
 *
 * @param baseUrl - The proxy's local base URL (e.g., "http://127.0.0.1:12345")
 */
declare function buildProviderModels(baseUrl: string): ModelProviderConfig;
/**
 * Check if a model is optimized for agentic workflows.
 * Agentic models continue autonomously with multi-step tasks
 * instead of stopping and waiting for user input.
 */
declare function isAgenticModel(modelId: string): boolean;
/**
 * Get all agentic-capable models.
 */
declare function getAgenticModels(): string[];
/**
 * Get context window size for a model.
 * Returns undefined if model not found.
 */
declare function getModelContextWindow(modelId: string): number | undefined;

/**
 * Usage Logger
 *
 * Logs every LLM request as a JSON line to a daily log file.
 * Files: ~/.openclaw/blockrun/logs/usage-YYYY-MM-DD.jsonl
 *
 * MVP: append-only JSON lines. No rotation, no cleanup.
 * Logging never breaks the request flow — all errors are swallowed.
 */
type UsageEntry = {
    timestamp: string;
    model: string;
    tier: string;
    cost: number;
    baselineCost: number;
    savings: number;
    latencyMs: number;
    /** Partner service ID (e.g., "x_users_lookup") — only set for partner API calls */
    partnerId?: string;
    /** Partner service name (e.g., "AttentionVC") — only set for partner API calls */
    service?: string;
};
/**
 * Log a usage entry as a JSON line.
 */
declare function logUsage(entry: UsageEntry): Promise<void>;

/**
 * Request Deduplication
 *
 * Prevents double-charging when OpenClaw retries a request after timeout.
 * Tracks in-flight requests and caches completed responses for a short TTL.
 */
type CachedResponse = {
    status: number;
    headers: Record<string, string>;
    body: Buffer;
    completedAt: number;
};
declare class RequestDeduplicator {
    private inflight;
    private completed;
    private ttlMs;
    constructor(ttlMs?: number);
    /** Hash request body to create a dedup key. */
    static hash(body: Buffer): string;
    /** Check if a response is cached for this key. */
    getCached(key: string): CachedResponse | undefined;
    /** Check if a request with this key is currently in-flight. Returns a promise to wait on. */
    getInflight(key: string): Promise<CachedResponse> | undefined;
    /** Mark a request as in-flight. */
    markInflight(key: string): void;
    /** Complete an in-flight request — cache result and notify waiters. */
    complete(key: string, result: CachedResponse): void;
    /** Remove an in-flight entry on error (don't cache failures).
     *  Also rejects any waiters so they can retry independently. */
    removeInflight(key: string): void;
    /** Prune expired completed entries. */
    private prune;
}

/**
 * Typed Error Classes for ClawRouter
 *
 * Provides structured errors for balance-related failures with
 * all necessary information for user-friendly error messages.
 */
/**
 * Thrown when wallet has insufficient USDC balance for a request.
 */
declare class InsufficientFundsError extends Error {
    readonly code: "INSUFFICIENT_FUNDS";
    readonly currentBalanceUSD: string;
    readonly requiredUSD: string;
    readonly walletAddress: string;
    constructor(opts: {
        currentBalanceUSD: string;
        requiredUSD: string;
        walletAddress: string;
    });
}
/**
 * Thrown when wallet has no USDC balance (or effectively zero).
 */
declare class EmptyWalletError extends Error {
    readonly code: "EMPTY_WALLET";
    readonly walletAddress: string;
    constructor(walletAddress: string);
}
/**
 * Type guard to check if an error is InsufficientFundsError.
 */
declare function isInsufficientFundsError(error: unknown): error is InsufficientFundsError;
/**
 * Type guard to check if an error is EmptyWalletError.
 */
declare function isEmptyWalletError(error: unknown): error is EmptyWalletError;
/**
 * Type guard to check if an error is a balance-related error.
 */
declare function isBalanceError(error: unknown): error is InsufficientFundsError | EmptyWalletError;
/**
 * Thrown when RPC call fails (network error, node down, etc).
 * Distinguishes infrastructure failures from actual empty wallets.
 */
declare class RpcError extends Error {
    readonly code: "RPC_ERROR";
    readonly originalError: unknown;
    constructor(message: string, originalError?: unknown);
}
/**
 * Type guard to check if an error is RpcError.
 */
declare function isRpcError(error: unknown): error is RpcError;

/**
 * Retry Logic for ClawRouter
 *
 * Provides fetch wrapper with exponential backoff for transient errors.
 * Retries on 429 (rate limit), 502, 503, 504 (server errors).
 */
/** Configuration for retry behavior */
type RetryConfig = {
    /** Maximum number of retries (default: 2) */
    maxRetries: number;
    /** Base delay in ms for exponential backoff (default: 500) */
    baseDelayMs: number;
    /** HTTP status codes that trigger a retry (default: [429, 502, 503, 504]) */
    retryableCodes: number[];
};
/** Default retry configuration */
declare const DEFAULT_RETRY_CONFIG: RetryConfig;
/**
 * Wrap a fetch-like function with retry logic and exponential backoff.
 *
 * @param fetchFn - The fetch function to wrap (can be standard fetch or x402 payFetch)
 * @param url - URL to fetch
 * @param init - Fetch init options
 * @param config - Retry configuration (optional, uses defaults)
 * @returns Response from successful fetch or last failed attempt
 *
 * @example
 * ```typescript
 * const response = await fetchWithRetry(
 *   fetch,
 *   "https://api.example.com/endpoint",
 *   { method: "POST", body: JSON.stringify(data) },
 *   { maxRetries: 3 }
 * );
 * ```
 */
declare function fetchWithRetry(fetchFn: (url: string, init?: RequestInit) => Promise<Response>, url: string, init?: RequestInit, config?: Partial<RetryConfig>): Promise<Response>;
/**
 * Check if an error or response indicates a retryable condition.
 */
declare function isRetryable(errorOrResponse: Error | Response, config?: Partial<RetryConfig>): boolean;

/**
 * Usage Statistics Aggregator
 *
 * Reads usage log files and aggregates statistics for terminal display.
 * Supports filtering by date range and provides multiple aggregation views.
 */
type DailyStats = {
    date: string;
    totalRequests: number;
    totalCost: number;
    totalBaselineCost: number;
    totalSavings: number;
    avgLatencyMs: number;
    byTier: Record<string, {
        count: number;
        cost: number;
    }>;
    byModel: Record<string, {
        count: number;
        cost: number;
    }>;
};
type AggregatedStats = {
    period: string;
    totalRequests: number;
    totalCost: number;
    totalBaselineCost: number;
    totalSavings: number;
    savingsPercentage: number;
    avgLatencyMs: number;
    avgCostPerRequest: number;
    byTier: Record<string, {
        count: number;
        cost: number;
        percentage: number;
    }>;
    byModel: Record<string, {
        count: number;
        cost: number;
        percentage: number;
    }>;
    dailyBreakdown: DailyStats[];
    entriesWithBaseline: number;
};
/**
 * Get aggregated statistics for the last N days.
 */
declare function getStats(days?: number): Promise<AggregatedStats>;
/**
 * Format stats as ASCII table for terminal display.
 */
declare function formatStatsAscii(stats: AggregatedStats): string;

/**
 * Partner Service Registry
 *
 * Defines available partner APIs that can be called through ClawRouter's proxy.
 * Partners provide specialized data (Twitter/X, etc.) via x402 micropayments.
 * The same wallet used for LLM calls pays for partner API calls — zero extra setup.
 */
type PartnerServiceParam = {
    name: string;
    type: "string" | "string[]" | "number";
    description: string;
    required: boolean;
};
type PartnerServiceDefinition = {
    /** Unique service ID used in tool names: blockrun_{id} */
    id: string;
    /** Human-readable name */
    name: string;
    /** Partner providing this service */
    partner: string;
    /** Short description for tool listing */
    description: string;
    /** Proxy path (relative to /v1) */
    proxyPath: string;
    /** HTTP method */
    method: "GET" | "POST";
    /** Parameters for the tool's JSON Schema */
    params: PartnerServiceParam[];
    /** Pricing info for display */
    pricing: {
        perUnit: string;
        unit: string;
        minimum: string;
        maximum: string;
    };
    /** Example usage for help text */
    example: {
        input: Record<string, unknown>;
        description: string;
    };
};
/**
 * All registered partner services.
 * New partners are added here — the rest of the system picks them up automatically.
 */
declare const PARTNER_SERVICES: PartnerServiceDefinition[];
/**
 * Get a partner service by ID.
 */
declare function getPartnerService(id: string): PartnerServiceDefinition | undefined;

/**
 * Partner Tool Builder
 *
 * Converts partner service definitions into OpenClaw tool definitions.
 * Each tool's execute() calls through the local proxy which handles
 * x402 payment transparently using the same wallet.
 */
/** OpenClaw tool definition shape (duck-typed) */
type PartnerToolDefinition = {
    name: string;
    description: string;
    inputSchema: {
        type: "object";
        properties: Record<string, unknown>;
        required: string[];
    };
    execute: (args: Record<string, unknown>) => Promise<unknown>;
};
/**
 * Build OpenClaw tool definitions for all registered partner services.
 * @param proxyBaseUrl - Local proxy base URL (e.g., "http://127.0.0.1:8402")
 */
declare function buildPartnerTools(proxyBaseUrl: string): PartnerToolDefinition[];

/**
 * @blockrun/clawrouter
 *
 * Smart LLM router for OpenClaw — 30+ models, x402 micropayments, 78% cost savings.
 * Routes each request to the cheapest model that can handle it.
 *
 * Usage:
 *   # Install the plugin
 *   openclaw plugins install @blockrun/clawrouter
 *
 *   # Fund your wallet with USDC on Base (address printed on install)
 *
 *   # Use smart routing (auto-picks cheapest model)
 *   openclaw models set blockrun/auto
 *
 *   # Or use any specific BlockRun model
 *   openclaw models set openai/gpt-5.2
 */

declare const plugin: OpenClawPluginDefinition;

export { type AggregatedStats, BALANCE_THRESHOLDS, BLOCKRUN_MODELS, type BalanceInfo, BalanceMonitor, type CachedLLMResponse, type CachedPaymentParams, type CachedResponse, DEFAULT_RETRY_CONFIG, DEFAULT_ROUTING_CONFIG, DEFAULT_SESSION_CONFIG, type DailyStats, EmptyWalletError, InsufficientFundsError, type InsufficientFundsInfo, type LowBalanceInfo, MODEL_ALIASES, OPENCLAW_MODELS, PARTNER_SERVICES, type PartnerServiceDefinition, type PartnerToolDefinition, PaymentCache, type PaymentFetchResult, type PreAuthParams, type ProxyHandle, type ProxyOptions, RequestDeduplicator, ResponseCache, type ResponseCacheConfig, type RetryConfig, type RoutingConfig, type RoutingDecision, RpcError, type SessionConfig, type SessionEntry, SessionStore, type SufficiencyResult, type Tier, type UsageEntry, blockrunProvider, buildPartnerTools, buildProviderModels, calculateModelCost, createPaymentFetch, plugin as default, fetchWithRetry, formatStatsAscii, getAgenticModels, getFallbackChain, getFallbackChainFiltered, getModelContextWindow, getPartnerService, getProxyPort, getSessionId, getStats, isAgenticModel, isBalanceError, isEmptyWalletError, isInsufficientFundsError, isRetryable, isRpcError, logUsage, resolveModelAlias, route, startProxy };
